# INNER JOIN

## What 

`INNER JOIN` in PostgreSQL combines rows from two or more tables based on a matching condition. It only returns rows where there is a match in both tables.

---

## Why

Use `INNER JOIN` when you need only related data from multiple tables.  
**Examples:**
- Get all orders with their customer details (skip customers with no orders).
- Fetch products that belong to existing categories.

---

## How 

**Syntax:**
```sql
SELECT table1.column, table2.column
FROM table1
INNER JOIN table2
ON table1.common_column = table2.common_column;
```

**Example:**
```sql
-- Customers with their Orders
SELECT c.customer_id, c.name, o.order_id, o.amount
FROM customers c
INNER JOIN orders o
ON c.customer_id = o.customer_id;
```

**Explanation:**
- `customers` is table1, `orders` is table2.
- The `ON` condition (`c.customer_id = o.customer_id`) matches rows.
- Only customers who have orders will show up.

---

## Key Points

- If there’s no match, the row is skipped.
- You can join more than two tables by chaining multiple `INNER JOIN`s.
- `INNER JOIN` is the default join — writing just `JOIN` means `INNER JOIN`.

---

## Query

### Tables Setup

```sql
-- Customers table
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(50),
    city VARCHAR(50)
);

-- Orders table
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT,
    amount NUMERIC(10, 2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

-- Sample data
INSERT INTO customers (name, city) VALUES
('Alice', 'New York'),
('Bob', 'Chicago'),
('Charlie', 'Los Angeles');

INSERT INTO orders (customer_id, amount) VALUES
(1, 250.00),
(1, 125.50),
(3, 300.00);
```

### INNER JOIN Query

```sql
SELECT c.customer_id, c.name, o.order_id, o.amount
FROM customers c
INNER JOIN orders o
ON c.customer_id = o.customer_id;
```

### Output

| customer_id | name    | order_id | amount  |
|-------------|---------|----------|---------|
| 1           | Alice   | 1        | 250.00  |
| 1           | Alice   | 2        | 125.50  |
| 3           | Charlie | 3        | 300.00  |

**Why this output?**  
Bob (`customer_id` 2) doesn’t appear because he has no matching order.  
Only rows where `customer_id` exists in both tables are shown.

## 🧠 Interview Explanation

An INNER JOIN in PostgreSQL retrieves rows that have matching values in both tables based on a specified condition. It’s used when you only want related data from multiple tables—ignoring records that don’t have a match. The join condition is defined in the ON clause, typically matching primary and foreign keys. For example, joining a customers table with an orders table on customer_id will return only customers who have placed at least one order, excluding those without orders. The operation works by scanning both tables and returning only rows where the join condition evaluates to true. You can join more than two tables by chaining multiple INNER JOINs, and in PostgreSQL, JOIN defaults to INNER JOIN if no type is specified. This join is essential for queries that require only intersecting data between tables, such as fetching orders with their customer details or products tied to existing categories.

<br>
<br>
<br>

# LEFT JOIN

## What
`LEFT JOIN` returns **all rows** from the left table, and the matching rows from the right table. If there's no match in the right table, it returns **NULL** for those columns.

## Why
We use `LEFT JOIN` when we want **everything from the left table**, even if there's no matching data in the right table. 

Examples:
- Show all customers, even if they never made an order
- List all products, even if some are not in stock records yet

## How
**Syntax:**
```sql
SELECT table1.column, table2.column 
FROM table1 
LEFT JOIN table2 ON table1.common_column = table2.common_column;
```

## Example
Using the **same tables** from the INNER JOIN example:

```sql
SELECT c.customer_id, c.name, o.order_id, o.amount 
FROM customers c 
LEFT JOIN orders o ON c.customer_id = o.customer_id;
```

**Output:**
| customer_id | name   | order_id | amount |
|-------------|--------|----------|--------|
| 1           | Alice  | 1        | 250.00 |
| 1           | Alice  | 2        | 125.50 |
| 2           | Bob    | NULL     | NULL   |
| 3           | Charlie| 3        | 300.00 |

## Key Difference from INNER JOIN:
- Bob appears here (with `NULL` for orders) because LEFT JOIN keeps **all left table rows**
- INNER JOIN would have skipped him completely

## 🧠 Interview Explanation

A LEFT JOIN in PostgreSQL returns all rows from the left (first) table and matches rows from the right (second) table based on the join condition. If there’s no matching row on the right side, it fills those columns with NULL. This is crucial when you want a complete list from the left table regardless of whether related data exists on the right. For example, joining customers with orders via a LEFT JOIN will show every customer, including those who haven’t placed any orders—the unmatched orders columns will simply be NULL. This contrasts with INNER JOIN, which only returns rows where matches exist on both sides. LEFT JOIN is perfect for reporting and analytics when you need to preserve the full dataset on one side while optionally including related details from another.

<br>
<br>
<br>

# RIGHT JOIN 

## What
`RIGHT JOIN` returns **all rows** from the **right table**, and the matching rows from the left table. If there's no match in the left table, it returns **NULL** for those columns.

## Why
We use `RIGHT JOIN` when we want **everything from the right table**, even if there's no matching data in the left table. 

Examples:
- Show all orders, even if some orders have no customer info (maybe data is incomplete)
- List all stock entries, even if the product details are missing

## How
**Syntax:**
```sql
SELECT table1.column, table2.column 
FROM table1 
RIGHT JOIN table2 ON table1.common_column = table2.common_column;
```

## Example
Using the same **customers** and **orders** tables:

```sql
SELECT c.customer_id, c.name, o.order_id, o.amount 
FROM customers c 
RIGHT JOIN orders o ON c.customer_id = o.customer_id;
```

**Output:**
| customer_id | name    | order_id | amount |
|-------------|---------|----------|--------|
| 1           | Alice   | 1        | 250.00 |
| 1           | Alice   | 2        | 125.50 |
| 3           | Charlie | 3        | 300.00 |

## Note:
- In this example, all orders have matching customers, so output looks like an INNER JOIN
- But if there was an order with a missing customer, it would still show up with `NULL` for customer columns

## 🧠 Interview Explanation

A RIGHT JOIN in PostgreSQL returns all rows from the right table and the matching rows from the left table based on the join condition. When there’s no corresponding match in the left table, the result includes the right table’s row with NULL in the left table’s columns. This join is useful when you want to keep every record from the right table regardless of matches on the left—for example, listing all orders even if some have missing or incomplete customer information. Unlike LEFT JOIN, which preserves the left table, RIGHT JOIN preserves the right table fully. In practice, RIGHT JOIN is just the mirror of LEFT JOIN and is less commonly used since you can often swap table positions and use LEFT JOIN instead, but it’s handy in certain query scenarios where you want to emphasize the right table’s data completeness.

<br>
<br>
<br>

# FULL JOIN 

## What
`FULL JOIN` (or `FULL OUTER JOIN`) returns **all rows from both tables**.
- If rows match, they're combined
- If no match, it fills with `NULL` on the side that's missing data

## Why
We use `FULL JOIN` when we want to see **everything from both tables** — matched or not. 

Example:
- Combine customer and order data, showing all customers and all orders, even if some customers have no orders and some orders have no customer info

## How
**Syntax:**
```sql
SELECT table1.column, table2.column 
FROM table1 
FULL JOIN table2 ON table1.common_column = table2.common_column;
```

## Example
Using the same `customers` and `orders` tables:

```sql
SELECT c.customer_id, c.name, o.order_id, o.amount 
FROM customers c 
FULL JOIN orders o ON c.customer_id = o.customer_id;
```

**Output:**
| customer_id | name    | order_id | amount |
|-------------|---------|----------|--------|
| 1           | Alice   | 1        | 250.00 |
| 1           | Alice   | 2        | 125.50 |
| 2           | Bob     | NULL     | NULL   |
| 3           | Charlie | 3        | 300.00 |
| NULL        | NULL    | 4        | 450.00 |

## What's going on?
- Alice and Charlie have orders, so rows are matched
- Bob has no orders, so order columns are NULL
- There's an order with no matching customer (order_id 4), so customer columns are NULL

## 🧠 Interview Explanation

A FULL JOIN (or FULL OUTER JOIN) in PostgreSQL returns all rows from both tables, combining matched rows based on the join condition and filling with NULL where there’s no match on either side. It’s the go-to when you want a complete picture of data from two tables—capturing matches and mismatches alike. For example, joining customers and orders with a FULL JOIN will show every customer (even those without orders) and every order (even those without customer info). This makes FULL JOIN powerful for comprehensive reports or data reconciliation tasks where you need to see all entries regardless of relational completeness. While less common than INNER or LEFT JOINs, FULL JOIN ensures no data is left behind from either table.

<br>
<br>
<br>

# CROSS JOIN 

## What
`CROSS JOIN` returns the **Cartesian product** of two tables. That means **every row from the first table paired with every row from the second table**.

## Why
We use `CROSS JOIN` when we want **all possible combinations** of rows between two tables. 

Examples:
- Generating all possible product and color combinations for a catalog
- Creating test data or schedules where every option pairs with every other

## How
**Syntax:**
```sql
SELECT * FROM table1 CROSS JOIN table2;
```

**Example:**
```sql
SELECT p.product_name, c.color_name 
FROM products p 
CROSS JOIN colors c;
```

If `products` has 3 rows and `colors` has 4 rows, result will have 3 × 4 = 12 rows.

## Important
- No `ON` condition needed
- Can be written simply as `FROM table1, table2` (old style), but explicit `CROSS JOIN` is clearer

## Quick Example with Data

```sql
-- Sample tables
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(50)
);

CREATE TABLE colors (
    color_id SERIAL PRIMARY KEY,
    color_name VARCHAR(20)
);

INSERT INTO products (product_name) VALUES ('Shirt'), ('Pants'), ('Hat');
INSERT INTO colors (color_name) VALUES ('Red'), ('Blue'), ('Green');

-- CROSS JOIN query
SELECT p.product_name, c.color_name 
FROM products p 
CROSS JOIN colors c;
```

**Output:**
| product_name | color_name |
|--------------|------------|
| Shirt        | Red        |
| Shirt        | Blue       |
| Shirt        | Green      |
| Pants        | Red        |
| Pants        | Blue       |
| Pants        | Green      |
| Hat          | Red        |
| Hat          | Blue       |
| Hat          | Green      |

⚠️ **Warning:** CROSS JOINs can explode your result size — watch out for that with large tables!

## 🧠 Interview Explanation

A CROSS JOIN returns the Cartesian product of two tables, meaning it pairs every row from the first table with every row from the second table. This results in all possible combinations of rows between the two sets. You use CROSS JOIN when you want exhaustive pairing—like generating all product-color combos for a catalog or creating comprehensive test data sets. Unlike other joins, CROSS JOIN doesn’t require an ON condition because it doesn’t match rows—it just multiplies them. For example, if you have 3 products and 4 colors, a CROSS JOIN returns 12 rows (3×4). It’s super powerful but can easily blow up result sizes with large tables, so handle with care. In older SQL, you could write it as FROM table1, table2, but explicitly writing CROSS JOIN improves clarity.

<br>
<br>
<br>

# SELF JOIN 

## What
A **SELF JOIN** is when a table joins with itself. It lets you compare rows within the same table.

## Why
Use SELF JOIN when you need to find relationships **between rows in the same table**. 

Example cases:
- Finding employees and their managers (both stored in one table)
- Comparing products with other products in the same table
- Finding pairs of related data inside one table

## How
You give the same table **two different aliases** to treat it like two tables, then join on conditions between those aliases.

## Syntax Example

```sql
SELECT a.employee_id, a.name AS employee, b.name AS manager 
FROM employees a 
LEFT JOIN employees b ON a.manager_id = b.employee_id;
```

**Explanation:**
- `employees` table joined with itself as `a` and `b`
- `a` represents the employee
- `b` represents the manager
- Join condition links `a.manager_id` to `b.employee_id` — finding each employee's manager name

## Example Data

**employees table:**
| employee_id | name    | manager_id |
|-------------|---------|------------|
| 1           | Alice   | NULL       |
| 2           | Bob     | 1          |
| 3           | Charlie | 1          |
| 4           | David   | 2          |

## Query Result

| employee_id | employee | manager |
|-------------|----------|---------|
| 1           | Alice    | NULL    |
| 2           | Bob      | Alice   |
| 3           | Charlie  | Alice   |
| 4           | David    | Bob     |

💡 **Pro tip:** SELF JOIN is super useful when you have hierarchical or related data inside one table and want to compare or combine rows.

## 🧠 Interview Explanation

A SELF JOIN is when a table joins with itself, allowing you to compare or relate rows within the same table by assigning different aliases to represent each instance. This technique is essential when you want to find relationships between data in the same table—like identifying employees and their managers stored in a single employees table. You alias the table twice (e.g., a and b) and join on a condition that relates rows across these aliases, such as matching an employee’s manager_id to another employee’s employee_id. This way, you can retrieve paired information, like each employee’s name alongside their manager’s name. SELF JOINs shine in hierarchical or relational data scenarios within a single table, giving you a powerful way to analyze internal connections without needing extra tables.
