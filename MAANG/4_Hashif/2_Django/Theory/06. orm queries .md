# üü¶ What is ORM in Django?

ORM (Object Relational Mapper) lets you interact with the database using Python objects instead of raw SQL.

**Instead of writing:**

```sql
SELECT * FROM product WHERE price > 500;
```

**You do:**

```python
Product.objects.filter(price__gt=500)
```

Django takes care of translating Python code into SQL queries behind the scenes.

---

## üîπ CRUD Operations (The Basics)

### Create

```python
product = Product.objects.create(title="Shoes", price=1200)
# or
product = Product(title="Shirt", price=800)
product.save()
```

### Read

```python
# All objects
Product.objects.all()

# Filter with conditions
Product.objects.filter(price__gte=500)

# Get a single object (throws error if not found or multiple)
Product.objects.get(id=1)

# First or last object
Product.objects.first()
Product.objects.last()

# Values QuerySet (returns dictionaries)
Product.objects.values("title", "price")
```

### Update

```python
product = Product.objects.get(id=1)
product.price = 1500
product.save()

# Bulk update
Product.objects.filter(category="Shoes").update(price=2000)
```

### Delete

```python
product = Product.objects.get(id=1)
product.delete()

# Bulk delete
Product.objects.filter(price__lt=200).delete()
```

---

## üîπ Common Filters and Lookups

| Lookup      | Example                                         | SQL Equivalent        |
|-------------|-------------------------------------------------|----------------------|
| exact       | `Product.objects.filter(title__exact="Shoes")`  | =                    |
| iexact      | case-insensitive exact match                    | ILIKE                |
| contains    | `Product.objects.filter(title__contains="shoe")`| LIKE '%shoe%'        |
| icontains   | case-insensitive contains                       | ILIKE '%shoe%'       |
| gt          | `price__gt=500`                                 | >                    |
| gte         | `price__gte=500`                                | >=                   |
| lt          | `price__lt=500`                                 | <                    |
| lte         | `price__lte=500`                                | <=                   |
| startswith  | `title__startswith="Sho"`                       | LIKE 'Sho%'          |
| in          | `id__in=[1,2,3]`                                | IN (1,2,3)           |
| isnull      | `price__isnull=True`                            | IS NULL              |

---

## üîπ Ordering and Limiting

```python
# Ascending
Product.objects.order_by("price")

# Descending
Product.objects.order_by("-price")

# Top 5 expensive
Product.objects.order_by("-price")[:5]
```

---

## üîπ Aggregation & Annotation

```python
from django.db.models import Count, Sum, Avg, Max, Min

# Average price
Product.objects.aggregate(Avg("price"))

# Total stock
Product.objects.aggregate(Sum("stock"))

# Count products per category
Category.objects.annotate(product_count=Count("product"))
```

---

## üîπ Relationships (ForeignKey, ManyToMany, OneToOne)

**Example models:**

```python
class Category(models.Model):
    name = models.CharField(max_length=100)

class Product(models.Model):
    title = models.CharField(max_length=100)
    category = models.ForeignKey(Category, on_delete=models.CASCADE)
```

**Queries:**

```python
# Products in a category
Category.objects.get(name="Shoes").product_set.all()

# Category of a product
Product.objects.get(id=1).category.name
```

---

## üîπ select_related vs prefetch_related

**Performance Boosters**

- `select_related`: For ForeignKey / OneToOne (joins in SQL).
- `prefetch_related`: For ManyToMany / reverse ForeignKey (does separate queries and caches them).

```python
# Avoids N+1 queries
products = Product.objects.select_related("category").all()

categories = Category.objects.prefetch_related("product_set").all()
```

---

## üîπ Raw SQL (only when needed)

```python
Product.objects.raw("SELECT * FROM product WHERE price > %s", [1000])
```

---

## ‚ö°Ô∏è Interview Tip

If they ask you about ORM queries, don‚Äôt just say the syntax. Explain why ORM is powerful:

- Prevents SQL injection
- Database-agnostic (works on PostgreSQL, MySQL, SQLite, etc.)
- Cleaner, more maintainable code

