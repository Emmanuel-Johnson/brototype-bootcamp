# AbstractUser 

## What
`AbstractUser` is a built-in Django class that gives you the **full default User model** but lets you **customize it by extending**. It includes all standard fields like username, email, password, first name, last name, plus Django's authentication features.

## Why
You use `AbstractUser` when you want:
- All the built-in user stuff **plus** some extra fields or methods
- To avoid rewriting all the basic auth logic yourself
- To keep Django's standard User system but tailor it for your app's needs

## How
You create your own user model that **inherits** from `AbstractUser`, then add fields or override methods.

**Example:**

```python
from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    phone_number = models.CharField(max_length=15, blank=True, null=True)
    # Add any extra fields you want
    
    def __str__(self):
        return self.username
```

Then, in your `settings.py`, tell Django to use your model:

```python
AUTH_USER_MODEL = 'yourapp.CustomUser'
```

## Key Points
- Extends Django's default User â€” keeps all its features
- Good for adding fields like phone number, profile pics, roles, etc.
- Easier than creating a user model from scratch (`AbstractBaseUser` is lower level and requires more work)
- Make sure to set `AUTH_USER_MODEL` **before** running migrations or creating users

## ðŸ§  Interview Explanation

AbstractUser is a built-in Django class that provides the full default User model with all standard fields like username, email, and password, along with Djangoâ€™s authentication features, while allowing you to easily customize it by extending. Itâ€™s the go-to choice when you want to keep Djangoâ€™s robust user system but add extra fields or methods specific to your app, like phone numbers or user roles, without rewriting authentication logic from scratch. You do this by creating a custom user model that inherits from AbstractUser, adding your fields, and then setting AUTH_USER_MODEL in settings.py to point to your custom model. This approach strikes the perfect balance between leveraging Djangoâ€™s built-in capabilities and tailoring the user model to your needs, but remember to set AUTH_USER_MODEL before running migrations to avoid issues.

<br>
<br>
<br>

# AbstractBaseUser 

## What?
`AbstractBaseUser` is a **bare-bones base class** for creating your own custom User model from scratch. It provides only **basic authentication functionality** like password handling and login/logout helpers, but **no fields** like username, email, etc.

## Why?
Use `AbstractBaseUser` when you want **full control** over your User model's fields and behavior, like:
- Using email instead of username as the login field
- Customizing user data and authentication logic heavily
- Building a User model that doesn't fit Django's default assumptions

## How?
You need to define all the important stuff yourself:
- Required fields (email, username, etc.)
- `USERNAME_FIELD` â€” which field is used for login
- Custom manager to handle creating users and superusers
- Permissions methods (`is_staff`, `is_superuser`, etc.)
- Implement some required methods like `get_full_name()`, `get_short_name()`

## Example Skeleton

```python
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.db import models

class CustomUserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError('Email must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        return self.create_user(email, password, **extra_fields)

class CustomUser(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True)
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    objects = CustomUserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['first_name', 'last_name']

    def get_full_name(self):
        return f"{self.first_name} {self.last_name}"

    def get_short_name(self):
        return self.first_name
```

Then in `settings.py`:

```python
AUTH_USER_MODEL = 'yourapp.CustomUser'
```

## Key Points
- More complex than `AbstractUser` but more flexible
- You're responsible for defining all fields and auth logic
- You must implement a custom user manager with `create_user` and `create_superuser`
- Great for when you want to ditch the username and use email or something else as the login

## ðŸ§  Interview Explanation

AbstractBaseUser is a minimal base class in Django designed for building a completely custom User model from scratch. Unlike AbstractUser, it provides only core authentication features like password handling but no default fields such as username or email, giving you full control over what fields and authentication logic to implement. Use AbstractBaseUser when you want to replace the username with email as the login field or heavily customize user data and permissions beyond Djangoâ€™s defaults. This approach requires you to define all essential fields, specify USERNAME_FIELD, create a custom user manager with create_user and create_superuser methods, and implement necessary permission and name retrieval methods. While itâ€™s more complex and requires more boilerplate than extending AbstractUser, itâ€™s ideal for flexible, tailored user authentication systems where Djangoâ€™s standard user model doesnâ€™t fit your needs. Remember to set AUTH_USER_MODEL in settings.py before running migrations.
