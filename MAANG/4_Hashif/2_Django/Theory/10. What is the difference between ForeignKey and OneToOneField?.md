# OneToOneField 

## What
`OneToOneField` is a special type of database relationship where **each record in one table is linked to exactly one record in another table** â€” like a one-to-one mapping.

## Why
You use `OneToOneField` when you want to **extend a model** without changing the original. Classic use case:
- Adding a `Profile` model that stores extra info about a `User` model (one user = one profile)

## How
You define a `OneToOneField` in your model, pointing to the other model:

```python
from django.contrib.auth.models import User
from django.db import models

class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    bio = models.TextField(blank=True)
    phone = models.CharField(max_length=15, blank=True)
    
    def __str__(self):
        return self.user.username
```

## Key points:
- `on_delete=models.CASCADE` means if the related User is deleted, the Profile is deleted too
- You can access the profile from user: `user.profile` (reverse lookup)
- Ensures strict one-to-one relationship; no multiple profiles for a single user

## Typical usage

```python
# Creating profile for a user
user = User.objects.create_user('emmanuel')
profile = Profile.objects.create(user=user, bio='Coding enthusiast')

# Accessing profile
print(user.profile.bio)  # Output: Coding enthusiast
```

OneToOneField = perfect for clean, modular user extensions or any strict one-to-one relationships in your data.

## ðŸ§  Interview Explanation

OneToOneField in Django defines a strict one-to-one relationship between two models, where each record in one table corresponds to exactly one record in another. Itâ€™s perfect for extending models without modifying the originalâ€”for example, adding a Profile model that holds extra information for each User. When you declare user = models.OneToOneField(User, on_delete=models.CASCADE), it means deleting the user will also delete the profile, maintaining data integrity. You can easily access the related profile from a user instance via user.profile. This relationship guarantees no duplicatesâ€”each user has only one profileâ€”making OneToOneField ideal for modular and clean model extensions or any scenario where a strict one-to-one mapping is needed.

<br>
<br>
<br>

# Many-to-One Relationship 

## What
**Many-to-One** means **many records in one table relate to a single record in another table**. In Django, this is done using a **ForeignKey** field.

## Why
You use Many-to-One when you want to link multiple objects to a single parent. Examples:
- Many `Order` records belong to one `Customer`
- Many `Comments` belong to one `BlogPost`

## How
You add a `ForeignKey` field in the "many" model pointing to the "one" model:

```python
from django.db import models

class Customer(models.Model):
    name = models.CharField(max_length=100)

class Order(models.Model):
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    order_date = models.DateTimeField()
    amount = models.DecimalField(max_digits=8, decimal_places=2)
```

## Key points:
- `on_delete=models.CASCADE` means if the Customer is deleted, all their Orders get deleted too
- You can access all orders of a customer via reverse relation:

```python
customer = Customer.objects.get(id=1)
orders = customer.order_set.all()  # Gets all orders for that customer
```

- You can customize the reverse relation name with `related_name`:

```python
customer = models.ForeignKey(Customer, on_delete=models.CASCADE, related_name='orders')

orders = customer.orders.all()  # Cleaner than order_set
```

## Usage example:

```python
# Create a customer
customer = Customer.objects.create(name='Emmanuel')

# Create orders for customer
Order.objects.create(customer=customer, order_date='2025-08-09', amount=150.00)
Order.objects.create(customer=customer, order_date='2025-08-10', amount=200.00)

# Access orders from customer
for order in customer.orders.all():
    print(order.amount)
```

Many-to-One is foundational for building relational models in Django â€” use it whenever you want multiple items linked to one parent.

## ðŸ§  Interview Explanation

In Django, a Many-to-One relationship means many records in one table relate to a single record in another, implemented via a ForeignKey field. This setup is ideal when you want multiple objects tied to one parentâ€”for example, many Order instances linked to a single Customer. Declaring customer = models.ForeignKey(Customer, on_delete=models.CASCADE) in the Order model means if a customer gets deleted, all their orders are removed too, keeping data consistent. You can access all orders of a customer through the reverse relation, typically customer.order_set.all(), or use a cleaner alias with related_name='orders' like customer.orders.all(). This relationship pattern is fundamental in Djangoâ€™s ORM for modeling real-world data where many items naturally belong to one entity, making it a must-know for building relational apps.

<br>
<br>
<br>

# One-to-Many Relationship

## Reality Check
**"One-to-Many"** and **"Many-to-One"** are just two ways of saying the **same relationship**, but from different sides. So when you hear "One-to-Many" in Django context, it's basically the flip side of "Many-to-One."

## Here's the breakdown:
- **Many-to-One:** Many child records point to one parent record (done with a `ForeignKey` on the child model)
- **One-to-Many:** One parent record has many child records (accessed via reverse relation from the parent)

## How Django models it:

```python
# Child side: Many-to-One using ForeignKey
class Order(models.Model):
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)

# Parent side: One-to-Many access via reverse relation
customer = Customer.objects.get(id=1)
orders = customer.order_set.all()  # default reverse accessor
```

## Pro tip:
Use `related_name` to make the reverse side cleaner:

```python
customer = models.ForeignKey(Customer, on_delete=models.CASCADE, related_name='orders')

orders = customer.orders.all()  # way nicer than order_set
```

<br>
<br>
<br>

# Many-to-Many Relationship 

## What
**Many-to-Many** means **multiple records in one table relate to multiple records in another table**. For example: a student can enroll in many courses, and each course can have many students.

## Why
Use Many-to-Many when you want to represent a relationship where both sides can have multiple related objects.

## How
Django uses a `ManyToManyField` to handle this automatically with an intermediate join table.

## Example

```python
from django.db import models

class Student(models.Model):
    name = models.CharField(max_length=100)

class Course(models.Model):
    title = models.CharField(max_length=100)
    students = models.ManyToManyField(Student, related_name='courses')
```

## Key points:
- Django creates an automatic **join table** behind the scenes
- You can access related objects from either side:

```python
# Get all courses a student is enrolled in
student = Student.objects.get(id=1)
courses = student.courses.all()

# Get all students in a course
course = Course.objects.get(id=1)
students = course.students.all()
```

- You can customize the join table by creating your own through model with extra fields

## Usage example:

```python
# Create student and courses
s1 = Student.objects.create(name='Emmanuel')
c1 = Course.objects.create(title='Python Basics')
c2 = Course.objects.create(title='Django Advanced')

# Add courses to student
s1.courses.add(c1, c2)

# Access courses of the student
for course in s1.courses.all():
    print(course.title)
```

Many-to-Many is the go-to when relationships are complex and bidirectional.

## ðŸ§  Interview Explanation

A Many-to-Many relationship in Django means multiple records in one table relate to multiple records in anotherâ€”like students enrolling in many courses, and courses having many students. Django handles this elegantly using a ManyToManyField, which automatically creates an intermediate join table behind the scenes. You can easily access related objects from either side, for example, retrieving all courses a student is enrolled in or all students in a course, using student.courses.all() or course.students.all(). If needed, you can customize the join table by creating your own through model to add extra fields. This pattern is essential for modeling complex, bidirectional relationships and is a fundamental tool in Djangoâ€™s ORM for real-world apps where many-to-many links exist.
