# Signals 

## What
Signals in Django are **hooks** or **events** that let parts of your app **talk to each other** when something happens. Think of them as notifications sent when certain actions occur, like saving a model, deleting an object, or user login.

## Why
You use signals to **decouple code** and run extra logic automatically without cluttering your main code. For example:
- Automatically creating a profile after a user signs up
- Clearing cache when a model updates
- Sending emails after an object is saved

## How
1. **Define a receiver function** that does the work you want when the signal fires
2. **Connect the receiver** to the signal (either via a decorator or `connect` method)

## Common built-in signals:
- `post_save` ‚Äî after a model is saved
- `pre_save` ‚Äî before a model is saved
- `post_delete` ‚Äî after a model is deleted
- `pre_delete` ‚Äî before a model is deleted
- `m2m_changed` ‚Äî when a many-to-many relationship changes
- `user_logged_in`, `user_logged_out` (from `django.contrib.auth`)

## Example: Automatically create a Profile when User is created

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from .models import Profile

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)

@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    instance.profile.save()
```

## Pro tips:
- Put signals in a separate `signals.py` file inside your app for clarity
- Make sure to import your signals module in the app's `apps.py` inside `ready()` so Django loads them
- Avoid heavy processing in signals; offload to tasks if needed

## Examples 

### Create or update related objects quickly
Example: When a User is created, automatically create a lightweight UserProfile object linked to that user.

### Maintain denormalized data
Like updating a count or status on a related model when something changes. For example, updating post.comment_count when a new comment is added.

### Trigger cache invalidation for small caches
If your cache key invalidation logic is simple and fast ‚Äî keep it here to ensure data freshness.

### Send quick notifications internally
Like toggling a flag or sending an in-app notification that doesn‚Äôt require network calls.

### Enqueue background jobs
This is the big one: use signals to kick off background tasks (e.g., with Celery, RQ). For instance, signal says ‚ÄúHey, send welcome email!‚Äù ‚Äî but the actual sending happens asynchronously.

### Why these?
Because signals fire synchronously, meaning your user waits for them to finish. So only put stuff that takes a few milliseconds tops.

## üß† Interview Explanation

Django signals are built-in event hooks that let different parts of your app automatically communicate and respond when actions occur‚Äîlike after saving or deleting a model, or when a user logs in. They help keep your code clean and decoupled by running extra logic outside your core workflows, such as creating a user profile after registration or clearing cache on updates. You create a receiver function that listens to a specific signal (e.g., post_save) and connect it using a decorator or the connect() method. Common signals include post_save, pre_save, and m2m_changed. For proper setup, place your signals in a signals.py file and import it in your app‚Äôs apps.py under the ready() method to ensure Django loads them. Keep signal handlers lightweight and offload heavy processing to background tasks to maintain app performance.
