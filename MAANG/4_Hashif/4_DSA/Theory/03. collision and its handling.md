# üü¶ Collision and its handling

## 1. What is it?
A collision happens in a hash table when two different keys are hashed to the same index.

> **Analogy:**  
> You and your friend both get assigned the same locker number at the gym ‚Äî that‚Äôs a collision.

**Example:**
```python
hash("apple") % 10   # ‚Üí index 3  
hash("orange") % 10  # ‚Üí index 3  ‚Üê Collision!
```

---

## 2. Why it matters?
Hashing is supposed to give us **O(1)** time for lookup, insertion, and deletion.  
If collisions aren‚Äôt handled properly, performance drops ‚Äî sometimes even down to **O(n)** in the worst case.

> Knowing how to handle collisions efficiently is key to keeping performance solid.

---

## 3. How it works (Collision Handling Techniques)

There are two main strategies for collision resolution:

### üß© A. Chaining (Separate Chaining)
- Each index of the hash table stores a list (or linked list) of key-value pairs.
- If multiple keys hash to the same index, they are stored in that list.

**Pros:**
- ‚úÖ Easy to implement
- ‚úÖ No need to resize immediately

**Cons:**
- ‚ùå Slower lookup if chains grow long

**Example:**
```python
hash_table = {
    3: [("apple", 1), ("orange", 2)]
}
```

---

### üß± B. Open Addressing
- All elements are stored inside the hash table ‚Äî no lists.
- If collision occurs, it searches for the next empty slot using a strategy.

**Probing Techniques:**
- **Linear Probing:** `next_index = (index + 1) % size`
- **Quadratic Probing:** `index + i^2`
- **Double Hashing:** use a second hash function for jumps

**Pros:**
- ‚úÖ Saves memory

**Cons:**
- ‚ùå Can get stuck if load factor is too high
- ‚ùå Needs resizing more often

---

## 4. When to use what?
- **Chaining:** When you want simplicity and can afford extra space (lists/linked lists).
- **Open Addressing:** When memory usage needs to stay tight and you‚Äôre okay with more complex logic.

---

## üß† Interview Explanation

In hashing, a collision occurs when two distinct keys hash to the same index in the hash table. Since each key should ideally map to a unique location, handling collisions is crucial for maintaining the performance of hash-based data structures. There are two primary strategies to handle collisions: separate chaining and open addressing. In chaining, each bucket stores a list of elements that hash to the same index, while in open addressing, all elements are stored in the table itself, and collisions are resolved by probing ‚Äî using techniques like linear, quadratic, or double hashing to find the next available slot. Choosing the right strategy depends on the use case, memory constraints, and expected load factor.
