# Time Complexity

## What
Time complexity measures how long an algorithm takes to run, based on the size of its input (usually called `n`).

## Why  
Understanding time complexity helps us predict how fast or slow code will run as input grows. This lets us write efficient programs and avoid slowdowns.

# How 
We analyze the number of operations the algorithm performs relative to `n`. For example:
- If steps double when `n` doubles, itâ€™s **O(n)**.
- If steps grow much slower (like doubling only when `n` squares), itâ€™s **O(log n)** or **O(n log n)**.

We ignore constant factors and lower-order terms, focusing on the dominant factor that affects growth.

## ðŸ§  Interview Explanation

Time complexity describes how an algorithmâ€™s runtime grows as input size (`n`) increases. It helps predict performance and ensures code scales efficiently. We count fundamental operations as `n` changes, focusing on dominant terms. For example, doubling input doubles steps (**O(n)**); if steps grow with the logarithm of `n`, itâ€™s **O(log n)**. Mastering time complexity is key to writing optimized, scalable algorithms.

<br>
<br>
<br>

# Space Complexity

## What  
Space complexity measures how much extra memory (RAM) an algorithm needs, depending on input size `n`.

## Why 
Memory is limited. Knowing space complexity helps avoid crashes or slowdowns when programs use too much memoryâ€”crucial for big data or devices with less RAM.

## How
We count additional variables, data structures, or function calls needed relative to `n`. For example:
- Using a fixed number of variables means **O(1)** space (constant space).
- Using an array or list that grows with input size means **O(n)** space.
- Recursive calls add to space complexity by increasing the call stack, often **O(log n)** or **O(n)** depending on recursion depth.

## ðŸ§  Interview Explanation
Space complexity is the extra memory an algorithm needs as input size (`n`) grows. Itâ€™s important for preventing crashes or slowdowns, especially with large datasets or limited memory. We evaluate space by counting extra variables, data structures, or recursive call stacks. Fixed variables mean **O(1)** space; arrays/lists proportional to input mean **O(n)**. Recursive algorithms add space via the call stack, which can be **O(log n)** or **O(n)**.
