# ðŸŸ© Merge Sort

## 1. What is it?
Merge Sort is a Divide and Conquer sorting algorithm that splits an array into halves, sorts each half recursively, and then merges the sorted halves into one.

## 2. Why it matters
Merge Sort is highly efficient (`O(n log n)`), stable, and predictable. It's ideal for large datasets or when you need to preserve the order of duplicate records (stability).

## 3. How it works
1. **Divide** the array into two halves.
2. **Recursively sort** each half.
3. **Merge** the sorted halves back together.

This process continues until each subarray contains a single element, then the merge phase builds the sorted array.

## 4. Example/Analogy
Imagine sorting papers:
- Split the stack into smaller stacks (divide).
- Sort each small stack individually (base case).
- Merge two sorted stacks into one big sorted stack.
- Repeat until everything is merged and sorted.

## 5. When to use it
- When you need a stable and guaranteed `O(n log n)` sort.
- Great for linked lists, external sorting, or very large datasets.
- When predictable performance is more important than minimal memory usage.

## 6. Pros and Cons
**âœ… Pros:**
- Time complexity is always `O(n log n)`
- Stable sorting
- Works well on large data

**âŒ Cons:**
- Uses extra space (`O(n)`)
- More complex than simple sorts (like Insertion or Bubble Sort)

## 7. Related Concepts
- Quick Sort (also divide and conquer, but in-place)
- Heap Sort
- Recursion
- Stability in Sorting
- Space vs Time Trade-off

## 8. Conclusion
Merge Sort is a professional-grade sorting algorithm: clean, recursive, and fast. It's your go-to when performance matters and you can't risk worst-case scenarios like in Quick Sort.

---

```python
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if left_half[i] <= right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1
```

---

## ðŸ§  Interview Explanation

Merge Sort is a divide-and-conquer algorithm that recursively divides the input array into halves, sorts them, and merges the sorted halves. It guarantees `O(n log n)` time complexity in all cases (best, average, worst), making it efficient for large datasets. Merge Sort is stable (preserves order of equal elements) and is commonly used when stability is required. However, it needs extra space for merging, which can be a drawback in memory-constrained environments. It's especially suitable for sorting linked lists or external storage.

### Time & Space Complexity

| Case    | Time Complexity |
|---------|----------------|
| Best    | O(n log n)     |
| Average | O(n log n)     |
| Worst   | O(n log n)     |

**Space:** `O(n)` (extra space used during merge step)
