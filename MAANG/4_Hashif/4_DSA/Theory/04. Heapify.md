## What 

Heapify is the process of adjusting part of a binary tree (often stored as an array) so that it satisfies the heap property:

- **Max-Heap:** Every parent is greater than or equal to its children.
- **Min-Heap:** Every parent is less than or equal to its children.

When heapify is called on a node, it assumes the children are already heaps and fixes the node and its subtree to maintain the heap property.

---

## Why 

Heapify is essential for maintaining the heap structure after:

- Adding a new element
- Removing the root element
- Building a heap from an unordered list

Without heapify, the heap structure breaks, making operations like finding the max/min or inserting/removing elements inefficient.

---

## How 

1. Start at node `i`.
2. Compare `i` with its left and right children.
3. Identify the largest (for max-heap) or smallest (for min-heap) among them.
4. If the parent is not the largest/smallest, swap it with the appropriate child.
5. Recursively heapify the affected subtree.

This process pushes the node down until the heap property is restored.

---

## Time and Space Complexity

- **Heapify on one node:** `O(log n)` (may traverse tree height)
- **Building a heap from an array:** `O(n)` (heapify called on all non-leaf nodes)
- **Space:** `O(1)` if iterative, `O(log n)` if recursive (due to call stack)

---

## Code 

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

# Example usage:
arr = [4, 10, 3, 5, 1]
n = len(arr)
heapify(arr, n, 0)
print(arr)  # Output: [10, 5, 3, 4, 1]
```

---

## ðŸ§  Interview Explanation

Heapify is a key operation in heaps that ensures a binary tree or subtree satisfies the heap propertyâ€”where each parent node is greater than (max-heap) or less than (min-heap) its children. It works by comparing a node with its children, swapping if needed, and recursively fixing the affected subtree. Heapify runs in `O(log n)` time and is crucial for building heaps from unsorted data and maintaining heap structure during insertions or deletions. This operation underpins efficient priority queues and sorting algorithms like heapsort, making it fundamental in algorithm design and optimization.
