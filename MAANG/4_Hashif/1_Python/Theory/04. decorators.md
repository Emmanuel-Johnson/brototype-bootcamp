# Decorators 

## 1. What is a Decorator?
A decorator in Python is a function that modifies or enhances another function or method without changing its actual code.  
It acts as a wrapper around a function and is implemented using the `@decorator_name` syntax.

## 2. Why Decorators Matter
- Add reusable functionality (logging, authentication, caching) without rewriting code.
- Core feature in frameworks like Django and Flask (e.g., `@login_required`).
- Improves code reusability, readability, and supports the DRY (Don‚Äôt Repeat Yourself) principle.

## 3. How Decorators Work

**Basic structure:**
```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Before the function runs")
        result = func(*args, **kwargs)
        print("After the function runs")
        return result
    return wrapper

@decorator
def say_hello():
    print("Hello!")

say_hello()
```

**Output:**
```
Before the function runs  
Hello!  
After the function runs  
```

- `@decorator` is shorthand for `say_hello = decorator(say_hello)`
- The wrapper function adds new behavior before/after the original function.

## 4. When to Use Decorators
- **Authentication:** `@login_required` in Django.
- **Logging/Debugging:** Log when functions are called.
- **Access Control:** Restrict certain users.
- **Memoization/Caching:** Store results to speed up repeated calls.
- **Validation:** Check arguments before execution.

## 5. Pros and Cons

**Pros**
- ‚úÖ Keeps code clean and DRY.
- ‚úÖ Adds functionality without touching original code.
- ‚úÖ Highly reusable and composable.

**Cons**
- ‚ùå Can make code harder to debug if overused.
- ‚ùå Beginners may find the flow confusing (functions returning functions).
- ‚ùå Improper use can hide side effects.

---

## üß† Interview Explanation
"A decorator in Python is a function that wraps another function or method to add or modify behavior without changing its source code, using the @decorator_name syntax. It works by taking a function as input, defining a wrapper function that executes additional logic before or after the original function, and then returning that wrapper. This makes it ideal for adding reusable features like logging, authentication, caching, access control, or input validation while keeping code clean and following the DRY principle. Decorators are heavily used in frameworks like Django and Flask ‚Äî for example, @login_required to restrict views to authenticated users. They keep code modular and reusable, though overuse can make debugging harder and the flow tricky for beginners."
