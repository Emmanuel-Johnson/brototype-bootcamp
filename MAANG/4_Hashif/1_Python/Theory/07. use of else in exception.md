## 1. What is it?

Exception handling is the process of managing errors in your code so your program doesn‚Äôt crash.  
In Python, it‚Äôs done using the `try` ‚Üí `except` ‚Üí `finally` (and optionally `else`) blocks.

---

## 2. Why it matters

- Prevents your program from breaking unexpectedly.
- Helps you gracefully recover from errors (like missing files, invalid inputs, or network issues).
- Makes your code robust and user-friendly.

---

## 3. How it works

### Basic Syntax

```python
try:
    risky_code
except SomeError:
    handle_error
else:
    run_if_no_error
finally:
    always_run_this
```

### Example

```python
try:
    num = int(input("Enter a number: "))
    print(10 / num)
except ZeroDivisionError:
    print("Error: You can't divide by zero üö´")
except ValueError:
    print("Error: Please enter a valid number üî¢")
else:
    print("Division successful ‚úÖ")
finally:
    print("Execution finished üîö")
```

---

## 4. When to use it

- When working with user input (they might enter bad data).
- For file operations (file may not exist).
- During database or network calls (connection might fail).
- In loops or large systems where one error shouldn‚Äôt crash everything.

---

## 5. Pros and Cons

### ‚úÖ Pros

- Prevents full program crashes.
- Lets you handle specific errors differently.
- Improves user experience with friendly error messages.
- `finally` ensures cleanup (closing files, DB connections, etc.).

### ‚ùå Cons

- Overusing `try`/`except` can hide bugs.
- If you catch too broad (`except:` without type), debugging becomes hard.
- Bad practice if you use it instead of validating inputs.

---

## 6. Common Built‚Äëin Exceptions

Here are some common exceptions with simple examples:

- `ValueError` ‚Üí Invalid type conversion  
    ```python
    int("abc")  # Raises ValueError
    ```
- `ZeroDivisionError` ‚Üí Dividing by zero  
    ```python
    10 / 0  # Raises ZeroDivisionError
    ```
- `FileNotFoundError` ‚Üí Opening a non-existent file  
    ```python
    open("missing.txt")  # Raises FileNotFoundError
    ```
- `TypeError` ‚Üí Wrong data type used  
    ```python
    len(5)  # Raises TypeError
    ```
- `IndexError` ‚Üí List index out of range  
    ```python
    [1, 2, 3][5]  # Raises IndexError
    ```
- `KeyError` ‚Üí Accessing missing dict key  
    ```python
    {"a": 1}["b"]  # Raises KeyError
    ```

---

### About the `else` Block

- The `else` block in exception handling runs only if no exceptions were raised in the `try` block.
- It's useful for code that should only execute when everything in `try` succeeds (e.g., processing data after successful validation).

Example:

```python
try:
    num = int(input("Enter a number: "))
    result = 10 / num
except (ValueError, ZeroDivisionError) as e:
    print("Error:", e)
else:
    print("Result is:", result)  # Runs only if no exception occurs
finally:
    print("Done!")
```


### ‚ö° Pro Tip

- Always catch specific exceptions first (e.g., `ValueError`), then broader ones.
- Use `finally` for cleanup (closing files, DB sessions).
- For multiple exceptions:

    ```python
    except (TypeError, ValueError) as e:
        print("Error:", e)
    ```

---

## üî• Bottom Line

Exception handling is mandatory in real-world projects ‚Äî you‚Äôll be using it a ton in Django views (e.g., handling missing objects, invalid queries, database errors).
