# Constructor

## What is it?
A **constructor** in Python is a special method (`__init__`) that runs automatically when you create (instantiate) an object from a class. It’s the setup code for your object.

## Why it matters
Constructors let you initialize object state (variables, connections, files, etc.) the moment you create the object. Without it, you’d have to set everything manually each time.

## How it works

- Defined as `def __init__(self, ...):` inside a class.
- Runs when you create an object.
- You can pass parameters to set up initial values.

### Example

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

s1 = Student("Emmanuel", 22)
print(s1.name)  # Emmanuel
```

## When to use it

- Whenever you want objects to start with a predefined state.
- To reduce repetitive code when creating many similar objects.

## Pros and Cons

**Pros**
- ✅ Automatic setup when object is created.
- ✅ Keeps initialization logic in one place.
- ✅ Makes code cleaner and less error-prone.

**Cons**
- ❌ If you overload it with too much logic, objects become heavy to create.
- ❌ Can be confusing if you hide too much setup behind the constructor.

<br>
<br>
<br>

# Destructor

## What is it?
A **destructor** in Python is a special method (`__del__`) that runs when an object is about to be destroyed (garbage-collected). It’s the cleanup code for your object.

## Why it matters
Useful when your object holds external resources (files, database connections, sockets) that should be released when the object is no longer needed.

## How it works

- Defined as `def __del__(self):`.
- Automatically called when Python’s garbage collector deletes the object (i.e., when nothing refers to it anymore).

### Example

```python
class FileHandler:
    def __init__(self, filename):
        self.file = open(filename, 'w')
        print("File opened")

    def __del__(self):
        self.file.close()
        print("File closed")

f = FileHandler("test.txt")
del f  # manually deletes object
```

## When to use it

- When you’re working with external resources like files, sockets, or network connections.
- When you need guaranteed cleanup (but usually, context managers are safer).

## Pros and Cons

**Pros**
- ✅ Automates cleanup → fewer memory leaks.
- ✅ Good for resources that must be explicitly released.

**Cons**
- ❌ Timing isn’t guaranteed (depends on Python’s garbage collector).
- ❌ If circular references exist, `__del__` may not run at all.
- ⚡ That’s why context managers (`with`) are usually better.

<br>
<br>
<br>

## ⚡ Pro Tip

- Use constructors (`__init__`) almost always.
- Use destructors (`__del__`) rarely; prefer context managers for predictable cleanup.
