# Constructor

## What is it?
A **constructor** in Python is a special method (`__init__`) that runs automatically when you create (instantiate) an object from a class. It‚Äôs the setup code for your object.

## Why it matters
Constructors let you initialize object state (variables, connections, files, etc.) the moment you create the object. Without it, you‚Äôd have to set everything manually each time.

## How it works

- Defined as `def __init__(self, ...):` inside a class.
- Runs when you create an object.
- You can pass parameters to set up initial values.

### Example

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

s1 = Student("Emmanuel", 21)
print(s1.name)  # Emmanuel
```

## When to use it

- Whenever you want objects to start with a predefined state.
- To reduce repetitive code when creating many similar objects.

## Pros and Cons

**Pros**
- ‚úÖ Automatic setup when object is created.
- ‚úÖ Keeps initialization logic in one place.
- ‚úÖ Makes code cleaner and less error-prone.

**Cons**
- ‚ùå If you overload it with too much logic, objects become heavy to create.
- ‚ùå Can be confusing if you hide too much setup behind the constructor.

## üß† Interview Explanation

A constructor in Python is a special method, __init__, that runs automatically when you create an object from a class. It‚Äôs used to initialize the object‚Äôs state ‚Äî for example, setting variables, opening files, or creating connections ‚Äî so you don‚Äôt have to manually configure it every time. You define it inside the class as def __init__(self, ...), and it‚Äôs triggered immediately upon instantiation. Constructors make code cleaner, reduce repetition, and keep initialization logic in one place. They‚Äôre essential when you want objects to start with predefined values, but loading them with too much logic can slow down object creation.

<br>
<br>
<br>

# Destructor

## What is it?
A **destructor** in Python is a special method (`__del__`) that runs when an object is about to be destroyed (garbage-collected). It‚Äôs the cleanup code for your object.

## Why it matters
Useful when your object holds external resources (files, database connections, sockets) that should be released when the object is no longer needed.

## How it works

- Defined as `def __del__(self):`.
- Automatically called when Python‚Äôs garbage collector deletes the object (i.e., when nothing refers to it anymore).

### Example

```python
class FileHandler:
    def __init__(self, filename):
        self.file = open(filename, 'w')
        print("File opened")

    def __del__(self):
        self.file.close()
        print("File closed")

f = FileHandler("test.txt")
del f  # manually deletes object
```

## When to use it

- When you‚Äôre working with external resources like files, sockets, or network connections.
- When you need guaranteed cleanup (but usually, context managers are safer).

## Pros and Cons

**Pros**
- ‚úÖ Automates cleanup ‚Üí fewer memory leaks.
- ‚úÖ Good for resources that must be explicitly released.

**Cons**
- ‚ùå Timing isn‚Äôt guaranteed (depends on Python‚Äôs garbage collector).
- ‚ùå If circular references exist, `__del__` may not run at all.
- ‚ö° That‚Äôs why context managers (`with`) are usually better.

## ‚ö° Pro Tip

- Use constructors (`__init__`) almost always.
- Use destructors (`__del__`) rarely; prefer context managers for predictable cleanup.

## üß† Interview Explanation

### Destructor
A destructor in Python is a special method, `__del__`, that executes when an object is about to be destroyed by Python‚Äôs garbage collector. It‚Äôs typically used for cleanup tasks like closing files, releasing database connections, or freeing other external resources. You define it inside the class as def `__del__`(self):, and Python calls it automatically when there are no more references to the object. While destructors can help prevent resource leaks, their timing isn‚Äôt guaranteed and they might not run in cases like circular references ‚Äî which is why context managers (with statements) are generally preferred for predictable cleanup.
