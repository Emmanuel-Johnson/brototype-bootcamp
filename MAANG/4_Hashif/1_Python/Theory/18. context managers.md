# üü¶ Context Managers 

## 1. What is it?

A context manager is an object that defines setup and cleanup behavior for a block of code.  
It tells Python what to do before and after running the block, powering the `with` statement.

Formally, a context manager implements:

- `__enter__(self)`: Runs at the start, returns an object (optional).
- `__exit__(self, exc_type, exc_val, exc_tb)`: Runs when the block ends (even if an exception happens).

---

## 2. Why it matters

- Handles resources safely and automatically.
- Prevents leaks (files left open, DB connections hanging, locks not released).
- Keeps code clean‚Äîreplaces bulky `try/finally` blocks.

---

## 3. How it works

### Example 1: File Context Manager (built‚Äëin)

```python
with open("data.txt", "r") as f:
    content = f.read()
# f.__exit__() called ‚Üí file is closed automatically
```

---

### Example 2: Custom Context Manager (class)

```python
class MyContext:
    def __enter__(self):
        print("Setup")
        return "Resource"
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Cleanup")

with MyContext() as res:
    print(res)
```

**Output:**
```
Setup
Resource
Cleanup
```

---

### Example 3: Context Manager with `contextlib`

Cleaner approach using a decorator:

```python
from contextlib import contextmanager

@contextmanager
def my_context():
    print("Setup")
    yield "Resource"
    print("Cleanup")

with my_context() as res:
    print(res)
```

---

## 4. When to use it

Managing resources that need automatic cleanup, such as:

- Files
- Database connections
- Network sockets
- Threading/multiprocessing locks
- Wrapping setup/teardown logic (like timers, logging, or temporary state)

---

## 5. Pros & Cons

**‚úÖ Pros**
- Guarantees cleanup even on exceptions.
- Cleaner code than manual `try/finally`.
- Widely supported (files, DBs, threads, etc.).

**‚ùå Cons**
- Requires implementing `__enter__` and `__exit__` (boilerplate).
- Can hide complexity from beginners.

---

## ‚ö° Bottom Line

A context manager is the brains behind the `with` statement.  
It defines what happens before and after a block of code, making resource handling automatic, safe, and Pythonic.
