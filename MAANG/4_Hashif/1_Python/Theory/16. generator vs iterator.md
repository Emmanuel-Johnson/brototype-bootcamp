# Iterator vs Generator 

## 🟦 Iterator

### 1. What is it?
An **iterator** is an object in Python that implements the iterator protocol:
- `__iter__()` → returns the iterator object itself.
- `__next__()` → returns the next value, raises `StopIteration` when done.

> **In short:** A thing you can loop over.

### 2. Why it matters
- Used under the hood in `for` loops.
- Saves memory compared to lists (doesn’t need everything at once).
- Core building block for all iteration in Python.

### 3. How it works
```python
numbers = [1, 2, 3]
it = iter(numbers)

print(next(it))  # 1
print(next(it))  # 2
print(next(it))  # 3
# next(it) -> StopIteration
```

### 4. When to use it
- When you want manual control over iteration (`next()` calls).
- When implementing custom iterable classes.

### 5. Pros & Cons
**Pros:**
- ✅ Memory efficient.
- ✅ Works naturally with loops.

**Cons:**
- ❌ Writing custom iterators manually is verbose.

> ⚡ **Bottom Line:** An iterator is the engine that powers iteration.

<br>
<br>
<br>

## 🟥 Generator

### 1. What is it?
A **generator** is a special type of iterator created with:
- A function using `yield`, or
- A generator expression `(x for x in range(...))`.

You don’t have to write `__iter__` / `__next__` yourself — Python does it for you.

### 2. Why it matters
- The lazy, easy way to make iterators.
- Clean, readable, and efficient for handling streams of data.

### 3. How it works

**Using `yield`:**
```python
def count_up_to(n):
    num = 1
    while num <= n:
        yield num
        num += 1

for x in count_up_to(3):
    print(x)
# Output: 1, 2, 3
```

**Generator expression:**
```python
squares = (x*x for x in range(5))
print(next(squares))  # 0
print(next(squares))  # 1
```

### 4. When to use it
- When working with large datasets you don’t want in memory at once.
- When you need infinite or streaming data.
- When you want cleaner code than writing full iterator classes.

### 5. Pros & Cons
**Pros:**
- ✅ Super memory efficient (lazy evaluation).
- ✅ Less boilerplate than manual iterators.
- ✅ Infinite sequences possible.

**Cons:**
- ❌ One‑time use → once exhausted, you can’t restart.
- ❌ Debugging can be trickier than lists.

> ⚡ **Bottom Line:** A generator is just a shortcut to build an iterator — leaner, cleaner, and lazy.

<br>
<br>
<br>

## ⚡ Quick Recap

- **Iterator:** Any object that follows the iterator protocol (`__iter__`, `__next__`).
- **Generator:** A convenient way to build an iterator (using `yield` or generator expressions).

> **Analogy:**  
> - Iterator = manual gear car.  
> - Generator = automatic car (still drives, less hassle).
