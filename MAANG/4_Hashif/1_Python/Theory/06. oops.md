## 1. What is it?

OOP (Object-Oriented Programming) in Python is a programming paradigm that organizes code around **objects** (real-world entities) and **classes** (blueprints for objects), instead of just functions and logic.

> Think of it like creating a factory (**class**) that builds products (**objects**).

---

## 2. Why it matters?

- Helps you structure large projects cleanly.
- Makes code reusable, modular, and easier to maintain.
- Models real-world problems more naturally.
- Used in almost all modern applications (web, AI, games, etc.).

---

## 3. How it works?

- **Class** → A blueprint/template.
- **Object** → An instance created from a class.
- **Attributes** → Variables inside a class/object.
- **Methods** → Functions inside a class.

**Basic Example:**

```python
class Car:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def drive(self):
        print(f"{self.brand} {self.model} is driving 🚗")

my_car = Car("Tesla", "Model X")
my_car.drive()  
# Tesla Model X is driving 🚗
```

---

## 4. Key Pillars of OOP

### 🔹 Encapsulation

Bundling data (attributes) and methods together in one unit (class).

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # private attribute

    def deposit(self, amount):
        self.__balance += amount
```
**Benefit:** Keeps data safe & controlled.

---

### 🔹 Inheritance

A class can inherit properties and methods from another class.

```python
class Animal:
    def speak(self):
        print("I make a sound")

class Dog(Animal):
    def speak(self):
        print("Woof!")
```
**Benefit:** Avoids duplicate code, promotes reuse.

---

### 🔹 Polymorphism

Same method name, but different behaviors.

```python
for animal in [Dog(), Animal()]:
    animal.speak()
```
**Benefit:** Flexible code that works with different object types.

---

### 🔹 Abstraction

Hiding implementation details; only exposing what’s necessary.

```python
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def start(self):
        pass
```
**Benefit:** Forces subclasses to follow a contract (like an interface).

---

## 5. When to use OOP?

- When your project involves entities with attributes and actions (e.g., Users, Products, Orders in e‑commerce).
- When you want modularity (split code into manageable pieces).
- When you need code reuse via inheritance.
- For complex systems (games, simulations, frameworks).

---

## 6. Pros and Cons

### ✅ Pros

- Cleaner and more modular code.
- Easier debugging and scaling.
- Real-world modeling feels natural.
- Supports reuse through inheritance.

### ❌ Cons

- Can be overkill for small scripts.
- Slightly slower due to abstraction layers.
- Needs good design — messy OOP can be worse than procedural code.

